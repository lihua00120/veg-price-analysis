# -*- coding: utf-8 -*-
"""菜價預測.ipynb

Automatically generated by Colab.

"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt


df = pd.read_csv('veg_prices_history.csv')

"""#EDA"""

df.head()

df.describe()

# 將交易日期轉成 pandas 的 datetime 格式
df['交易日期'] = pd.to_datetime(df['交易日期'], format='%Y/%m/%d', errors='coerce')

# 驗證
df['交易日期'].head()

tab_info = pd.DataFrame(df.dtypes).T.rename(index={0: 'column type'})
tab_info = pd.concat(
    [tab_info, pd.DataFrame(df.isnull().sum()).T.rename(index={0: 'null values'})],
    axis=0
)
tab_info

"""#groupby"""

print(df.columns)

df = df[['交易日期', '產品名稱', '加權平均價(元/公斤)']].copy()

df.set_index('交易日期', inplace=True)
df.index.name = '交易時間'

grouped_by_product = df.groupby('產品名稱')

# 將每個分組後的資料表存儲到獨立的變數中 (t1, t2, ...)
for i, (name, group) in enumerate(grouped_by_product):
    globals()[f't{i+1}'] = group
    print(f"產品名稱: {name} 儲存為變數 t{i+1}")

# 您現在可以透過 t1, t2 等變數來存取個別的資料表
# 例如：
# print(t1.head()) # 顯示第一個產品的資料

"""## Groupby分群之後 每個在畫成折線圖"""

potato_df = df[df['產品名稱'] == '馬鈴薯'].copy()

plt.figure(figsize=(10, 5))
plt.plot(potato_df.index, potato_df['加權平均價(元/公斤)'])
plt.xlabel('Trade Date')
plt.ylabel('Weighted Average Price (NTD/kg)')
plt.title('Potato - Weighted Average Price Over Time')
plt.grid(True)
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt

# 假設 grouped_by_product 已經在先前的執行中建立

for name, group in grouped_by_product:
    plt.figure(figsize=(8, 4)) # Reduced figure size
    plt.plot(group.index, group['加權平均價(元/公斤)'])
    plt.xlabel('Trade Date')
    plt.ylabel('Weighted Average Price (NTD/kg)')
    plt.title(f'Product: {name} - Total Transaction Volume Time Series')
    plt.grid(True)
    plt.tight_layout()
    plt.show()

"""#時間序分析ACF&PACF"""

# 假設您有 t1, t2, ..., t73 等變數
# 您可以根據實際的產品數量調整迴圈的範圍
num_products = len(grouped_by_product) # 根據之前的輸出，有73個產品

for i in range(1, num_products + 1):
    var_name = f't{i}'
    if var_name in globals(): # 檢查變數是否存在
        print(f"\n{var_name}.head():")
        print(globals()[var_name].head())
    else:
        print(f"變數 {var_name} 不存在。")

import numpy as np
from statsmodels.tsa.stattools import acf, pacf
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
import pandas as pd

for i in range(1, num_products + 1):
    var_name = f't{i}'

    if var_name in globals():  # 檢查變數是否存在
        df = globals()[var_name]

        # 取出數值型欄位（轉成 float）
        ts = pd.to_numeric(df['加權平均價(元/公斤)'], errors='coerce').dropna()

        # 資料太短就跳過
        if len(ts) < 5:
            print(f"{var_name} 資料太少（{len(ts)} 筆），跳過。")
            continue

        # 根據資料長度動態設定 nlags
        nlags = min(100, len(ts)//2 - 1)
        if nlags < 1:
            nlags = 1

        # 計算 ACF 和 PACF
        acf_vals = acf(ts, nlags=nlags, fft=False)
        pacf_vals = pacf(ts, nlags=nlags)

        # 找出前 6 個最大絕對值的 lag（排除 lag 0）
        acf_lags = np.argsort(np.abs(acf_vals[1:]))[::-1][:6] + 1
        pacf_lags = np.argsort(np.abs(pacf_vals[1:]))[::-1][:6] + 1

        # 畫圖
        fig, axes = plt.subplots(1, 2, figsize=(16, 4))
        plot_acf(ts, lags=nlags, ax=axes[0])
        plot_pacf(ts, lags=nlags, ax=axes[1])

        # 標註前 6 個最顯著 lag
        for lag in acf_lags:
            axes[0].annotate(f'{acf_vals[lag]:.2f}',
                             xy=(lag, acf_vals[lag]),
                             xytext=(lag, acf_vals[lag]+0.05),
                             ha='center', color='red', fontsize=8)

        for lag in pacf_lags:
            axes[1].annotate(f'{pacf_vals[lag]:.2f}',
                             xy=(lag, pacf_vals[lag]),
                             xytext=(lag, pacf_vals[lag]+0.05),
                             ha='center', color='blue', fontsize=8)

        axes[0].set_title(f'{var_name} - ACF（自相關函數）', fontsize=12)
        axes[1].set_title(f'{var_name} - PACF（偏自相關函數）', fontsize=12)
        plt.tight_layout()
        plt.show()

    else:
        print(f"變數 {var_name} 不存在。")

for i in range(1, num_products + 1):
    var_name = f't{i}'

    if var_name in globals():
        df = globals()[var_name]

        # 取出數值欄位，轉成 float
        ts = pd.to_numeric(df['加權平均價(元/公斤)'], errors='coerce').dropna()

        if len(ts) < 5:
            print(f"{var_name}: 資料太少，跳過\n")
            continue

        # 設定 nlags 不超過樣本數的一半
        nlags = min(100, len(ts)//2 - 1)
        if nlags < 1:
            nlags = 1

        # 計算 ACF / PACF
        acf_vals = acf(ts, nlags=nlags, fft=False)
        pacf_vals = pacf(ts, nlags=nlags)

        # 找前 6 個最大絕對值 lag
        acf_lags = np.argsort(np.abs(acf_vals[1:]))[::-1][:3] + 1
        pacf_lags = np.argsort(np.abs(pacf_vals[1:]))[::-1][:3] + 1

        # 列印結果
        print(f"=== {var_name} ===")
        print("前 6 個最顯著的 ACF lag 與相關係數：")
        for lag in acf_lags:
            print(f"lag {lag}: {acf_vals[lag]:.3f}")

        print("前 6 個最顯著的 PACF lag 與相關係數：")
        for lag in pacf_lags:
            print(f"lag {lag}: {pacf_vals[lag]:.3f}")
        print("-"*40)
    else:
        print(f"{var_name} 不存在")

"""#從這裡改，選前三個lag 丟進 model，問題是資料量過小，它可能抓不到"""

from sklearn.linear_model import LinearRegression

max_top_lags = 3  # 每個產品選出前 3 個最顯著 lag

for i in range(1, num_products + 1):
    var_name = f't{i}'

    if var_name in globals():
        df = globals()[var_name]
        ts = pd.to_numeric(df['加權平均價(元/公斤)'], errors='coerce').dropna()

        if len(ts) < max_top_lags + 2:
            print(f"{var_name}: 資料太少，跳過")
            continue

        # 根據 PACF 選出最顯著的 lag
        nlags = min(20, len(ts)//2 - 1)  # 最大 lag 不超過一半樣本
        pacf_vals = pacf(ts, nlags=nlags)
        top_lags = np.argsort(np.abs(pacf_vals[1:]))[::-1][:max_top_lags] + 1
        top_lags = sorted(top_lags)  # 排序，方便做 lag 特徵
        print(f"{var_name} 自動選出的 lag:", top_lags)

        # 建立 lag 特徵
        X = pd.DataFrame({f'lag_{k}': ts.shift(k) for k in top_lags})
        valid = X.notna().all(axis=1)
        X_valid = X[valid]
        Y_valid = ts[valid]

        # 擬合線性回歸
        lin_reg = LinearRegression()
        lin_reg.fit(X_valid, Y_valid)
        print(f"{var_name} R² Score: {lin_reg.score(X_valid, Y_valid):.2f}")

        # 預測並存回 DataFrame
        df.loc[X_valid.index, 'Predicted'] = lin_reg.predict(X_valid)

    else:
        print(f"{var_name} 不存在")

# === 預測未來一天並輸出 CSV ===
predictions = []

for name, group in grouped_by_product:
    ts = pd.to_numeric(group['加權平均價(元/公斤)'], errors='coerce').dropna()

    if len(ts) < max(top_lags) + 1:
        print(f"{name}: 資料太少，跳過")
        continue

    # 取得最後一筆樣本的 lag 特徵
    last_lags = ts.iloc[-np.array(top_lags)]
    X_future = last_lags.values.reshape(1, -1)

    # 預測未來一天價格
    y_pred = lin_reg.predict(X_future)[0]

    # 儲存結果
    predictions.append({
        "產品名稱": name,
        "預測明日菜價(元/公斤)": round(y_pred, 2)
    })

# === 輸出結果到 CSV ===
result_df = pd.DataFrame(predictions)
result_df.to_csv("/tmp/veg_pred.csv", index=False, encoding="utf-8-sig")

print("✅ 已完成，輸出veg_pred.csv")

check = pd.read_csv('veg_pred.csv')
check
